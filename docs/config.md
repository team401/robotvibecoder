# Config JSON Files

A config file provides the basic specifications of the template mechanism that will be generated.

Here's an example config:

```json
{
  "package": "subsystems.scoring",
  "name": "Elevator",
  "kind": "Elevator",
  "motors": ["leadMotor", "followerMotor"],
  "lead_motor": "leadMotor",
  "encoder": "elevatorEncoder"
}
```

## Creating a config file

`robotvibecoder` can automatically generate a config file, either through a template interactively

To generate a template config file, just run

```sh
robotvibecoder new config.json
```

The output file path (in this case `config.json`) can be any path where the config should be generated.

### Interactively generate a config

To interactively generate a config with a CLI wizard, add the `-i` or `--interactive` flag:

```sh
$ robotvibecoder new -i config.json
```

That will launch a wizard: here's an example usage:

```
[RobotVibeCoder] Creating a new config file
  This will create/overwrite a file at `output.json`
  Press Ctrl+C to cancel or [Enter] to continue
Interactively generating new config. Please enter each field and press [Enter].
Package: will come after frc.robot (e.g. `subsystems.scoring`)
> subsystems.scoring
Name: should be capitalized and should not end in Mechanism or Subsystem, as this is automatically added
> Elevator
Kind: Should be either 'Elevator', 'Arm', or 'Flywheel'
> Elevator
CAN Bus: whatever the name of the mechanism's bus is (e.g. `canivore`)
> canivore
Number of motors (an integer, >= 1)
> 2
Motor 1 name: a camelcase motor name (e.g. leadMotor)
> leadMotor
Motor 2 name: a camelcase motor name (e.g. leadMotor)
> followerMotor
Lead motor (must be one of previously defined motors)
> leadMotor
Encoder name: a camelcase encoder name (e.g. armEncoder)
> elevatorEncoder
[RobotVibeCoder] Writing config file at `output.json`
```

This process would produce the following JSON config:

```json
{
  "package": "subsystems.example",
  "name": "Elevator",
  "kind": "Elevator",
  "motors": ["leadMotor", "followerMotor"],
  "lead_motor": "leadMotor",
  "encoder": "elevatorEncoder"
}
```

## Config file fields

### Required fields

These fields are always required in each config, regardless of mechanism kind.

- #### `package`

  The package field is a string determining what package the resulting java files will be in. This should be lowercase, and starts after `frc.robot`. For example, the package string `subsystems.scoring` would add the following line to the top of the generated files:

  ```java
  package frc.robot.subsystems.scoring;
  ```

- #### `name`

  The name field is a string determining the name of the mechanism. This should be capitalized, and should not end with "mechanism" or "subsystem". For instance, the name string `Elevator` would generate IOs named `ElevatorIO.java`, `ElevatorIOTalonFX.java`, etc.

- #### `kind`

  The kind field is a string determining what kind of mechanism to generate. This should be either `Arm`, `Elevator`, or `Flywheel`. The kind (named kind instead of type because type is a reserved keyword in python) determines what type of sim to generate:
  
  - `Arm`: [`SingleJointedArmSim`](https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj/simulation/SingleJointedArmSim.html)
  - `Elevator`: [`ElevatorSim`](https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj/simulation/ElevatorSim.html)
  - `Flywheel`: [`FlywheelSim`](https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj/simulation/FlywheelSim.html)
  - `Indexer`: Rather than a physics sim, the Indexer Mechanism Kind aims to provide a simple indexing sim that can be integrated with [MapleSim](https://shenzhen-robotics-alliance.github.io/maple-sim/) later if necessary.

  **Note**: Currently, `Flywheel` is not yet supported. It is under development and will be usable soon.

- #### `canbus`

  The canbus field is a string field determining the name of the CAN bus that the devices will be on. For example, the default CAN bus when using a canivore is `canivore`

- #### `motors`

  The motors field is an array of strings defining the names of the motors of the mechanism. It is recommended for these names to be camel-cased (e.g. `leadMotor`). Each motor will be a field in the inputs object for whether or not it is connected, as well as fields for supply and stator current.

- #### `lead_motor`

  The lead_motor field is a string determining which of these motors should be treated as the "lead motor". In TalonFX IOs, this motor will be commanded with the Closed-Loop request while all other motors are commanded with follower requests to follow the lead motor. This value must be one of `motors`.

### Fields required by Elevators and Arms

These fields must only be present when `kind` is `Elevator` or `Arm`.

- #### `encoder`

  The encoder field is a string determining the name of the encoder that will be used for closed-loop control. This name is recommended for these names to be camel-cased (e.g. `armEncoder`). This field determines the name of the variable holding the encoder as well as its name in the IO objects.

### Fields required by Indexers

- #### `limit_sensing_method`

  The method the indexer will use to detect when it has indexed a gamepiece and should become inactive.

  This should be one of the following:

    - `Current` - To intake, run the motors until their stator current rises above a threshold for a period of time
    - `CANrange` - Use a CANrange as a limit switch
    - `CANdi` - Use a CANdi as a limit switch

- #### `limit_switch_name`

  The name of the limit switch, which must be present if and only if `limit_sensing_method` is `CANrange` or `CANdi`.
  