package frc.robot.subsystems.scoring;

import static edu.wpi.first.units.Units.Volts;

import com.ctre.phoenix6.StatusSignal;
import com.ctre.phoenix6.configs.CANrangeConfiguration;
import com.ctre.phoenix6.configs.CurrentLimitsConfigs;
import com.ctre.phoenix6.configs.MotorOutputConfigs;
import com.ctre.phoenix6.configs.ProximityParamsConfigs;
import com.ctre.phoenix6.configs.TalonFXConfiguration;
import com.ctre.phoenix6.controls.VoltageOut;
import com.ctre.phoenix6.hardware.CANrange;
import com.ctre.phoenix6.hardware.TalonFX;
import com.ctre.phoenix6.signals.NeutralModeValue;
import edu.wpi.first.units.measure.Angle;
import edu.wpi.first.units.measure.MutVoltage;
import edu.wpi.first.units.measure.Voltage;
import frc.robot.constants.JsonConstants;

public class ClawIOTalonFX implements ClawIO {
{%- if limit_sensing_method != "Current" %}
  {{ limit_sensing_method }} {{ limit_switch_name}} = new {{ limit_sensing_method }}({{ name }}Constants.synced.getObject().{{ limit_switch_name }}ID, "{{ canbus }}");

  /** Should the hardware limit switch be enabled currently */
  private boolean obeyLimitSwitch = false;

{%- endif %}
{%- for motor in motors %}
  TalonFX {{ motor }} = new TalonFX({{ name }}Constants.synced.getObject().{{ motor }}ID, "{{ canbus }}");
{%- endfor %}

  private MutVoltage outputVoltage = Volts.mutable(0.0);
  private VoltageOut voltageRequest = new VoltageOut(outputVoltage);

  {%- if limit_sensing_method == "CANrange" %}
  private StatusSignal<Boolean> {{ limit_switch_name }}Detected = {{ limit_switch_name }}.getIsDetected();
  {%- endif %}
  {%- if limit_sensing_method == "CANdiS1" or limit_sensing_method == "CANdiS2" %}
  private StatusSignal<Boolean> {{ limit_switch_name }}Closed = {{ limit_switch_name }}.get{{ limit_sensing_method|candi_signal}}Closed();
  {%- endif %}
  {%- for motor in motors %}
  private StatusSignal<Current> {{ motor }}SupplyCurrent;
  private StatusSignal<Current> {{ motor }}StatorCurrent;

  {% endfor %}
  public ClawIOTalonFX() {
    TalonFXConfiguration talonFXConfigs =
        new TalonFXConfiguration()
            .withMotorOutput(
                new MotorOutputConfigs()
                    .withInverted({{ name }}Constants.synced.getObject().k{{ lead_motor|upperfirst }}Inverted)
                    .withNeutralMode(NeutralModeValue.Brake))
            {%- if limit_sensing_method != "Current" %}
            .withHardwareLimitSwitch(
              new HardwareLimitSwitchConfigs()
                .withForwardLimitRemote{{ limit_sensing_method }}({{ limit_switch_name }}))
            {%- endif %}
            .withCurrentLimits(
                new CurrentLimitsConfigs()
                    .withSupplyCurrentLimit({{ name }}Constants.synced.getObject().supplyCurrentLimit)
                    .withStatorCurrentLimit({{ name }}Constants.synced.getObject().statorCurrentLimit));

    {{ lead_motor }}.getConfigurator().apply(talonFXConfigs);
{% for motor in motors %}
{%- if motor != lead_motor %}

    talonFXConfigs.MotorOutput.Inverted = {{ name }}Constants.synced.getObject().k{{ motor|upperfirst }}Inverted;
    {{ motor }}.getConfigurator().apply(talonFXConfigs);
{%- endif %}
{%- endfor %}
{%- if motors|length > 1 %}

    talonFXConfigs.MotorOutput.Inverted = {{ name }}Constants.synced.getObject().k{{ leadMotor|upperfirst }}Inverted;
{%- endif %}

{%- if limit_sensing_method == "CANrange" %}
    CANrangeConfiguration {{ limit_switch_name }}Configs =
        new CANrangeConfiguration()
            .withProximityParams(
                new ProximityParamsConfigs()
                    .withMinSignalStrengthForValidMeasurement(
                        {{ name }}Constants.synced.getObject().{{ limit_switch_name }}MinSignalStrengthForValidMeasurement)
                    .withProximityThreshold({{ name }}Constants.synced.getObject().{{ limit_switch_name }}ProximityThreshold)
                    .withProximityHysteresis({{ name }}Constants.synced.getObject().{{ limit_switch_name }}ProximityHysteresis));

    {{ limit_switch_name }}.getConfigurator().apply({{ limit_switch_name }}Configs);
{%- endif %}
{%- if limit_sensing_method == "CANdiS1" or limit_sensing_method == "CANdiS2" %}
    CANdiConfiguration candiConfigs =
      new CANdiConfiguration()
        .withDigitalInputs(
          new DigitalInputsConfigs()
            .with{{ limit_sensing_method|candi_signal }}CloseState({{ limit_sensing_method|candi_signal }}CloseStateValue.CloseWhenHigh)
            .with{{ limit_sensing_method|candi_signal }}FloatState({{ limit_sensing_method|candi_signal }}FloatStateValue.PullLow)
        );
{%- endif %}

    BaseStatusSignal.setUpdateFrequencyForAll(50.0,
        {%- for motor in motors%}
        {{ motor }}SupplyCurrent,
        {{ motor }}StatorCurrent,
        {%- endfor %}
        {%- if limit_sensing_method == "CANrange" %}
        {{ limit_switch_name }}Detected,
        {%- endif %}
        {%- if limit_sensing_method == "CANdiS1" or limit_sensing_method == "CANdiS2" %}
        {{ limit_switch_name }}Closed,
        {%- endif %}
    );
  }

  public void updateInputs(ClawInputs inputs) {
    inputs.{{ game_piece|lowerfirst }}Detected = isAlgaeDetected();

    inputs.algaeSignalStrength = algaeRange.getSignalStrength().getValueAsDouble();
    inputs.algaeDistance.mut_replace(algaeRange.getDistance().getValue());

    inputs.algaeRangeConnected =
        algaeRange.isConnected()
            && StatusSignal.isAllGood(
                algaeRange.getIsDetected(),
                algaeRange.getSignalStrength(),
                algaeRange.getDistance());

    inputs.coralSignalStrength = coralRange.getSignalStrength().getValueAsDouble();
    inputs.coralDistance.mut_replace(coralRange.getDistance().getValue());

    inputs.coralRangeConnected =
        coralRange.isConnected()
            && StatusSignal.isAllGood(
                coralRange.getIsDetected(),
                coralRange.getSignalStrength(),
                coralRange.getDistance());

    inputs.clawMotorPos.mut_replace({{ lead_motor }}.getPosition().getValue());

    inputs.clawStatorCurrent.mut_replace({{ lead_motor }}.getStatorCurrent().getValue());
    inputs.clawSupplyCurrent.mut_replace({{ lead_motor }}.getSupplyCurrent().getValue());
  }

  public void applyOutputs(ClawOutputs outputs) {
    {%- if limit_sensing_method != "Current" %}
    voltageRequest.withIgnoreHardwareLimits(!obeyLimitSwitch);
{% endif %}
    {{ lead_motor }}.setControl(voltageRequest.withOutput(outputVoltage));

    outputs.clawAppliedVolts.mut_replace({{ lead_motor }}.getMotorVoltage());
  }

  public void setVoltage(Voltage volts) {
    outputVoltage.mut_replace(volts);
  }

  public Angle getClawMotorPos() {
    return {{ lead_motor }}.getPosition().getValue();
  }

  public boolean isCoralDetected() {
    return coralRange.getIsDetected().getValue();
  }

  public boolean isAlgaeDetected() {
    return algaeRange.getIsDetected().getValue();
  }
  {%- if limit_sensing_method != "Current" %}

  public void setObeyLimitSwitch(boolean obeyLimitSwitch) {
    this.obeyLimitSwitch = obeyLimitSwitch;
  }
  {%- endif%}
}
