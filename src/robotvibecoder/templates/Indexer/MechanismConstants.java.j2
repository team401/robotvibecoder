package frc.robot.constants;

import static edu.wpi.first.units.Units.Amps;
import static edu.wpi.first.units.Units.Centimeters;
import static edu.wpi.first.units.Units.Rotations;
import static edu.wpi.first.units.Units.Seconds;
import static edu.wpi.first.units.Units.Volts;

import com.ctre.phoenix6.signals.InvertedValue;
import coppercore.parameter_tools.json.JSONExclude;
import coppercore.parameter_tools.json.JSONSync;
import coppercore.parameter_tools.json.JSONSyncConfigBuilder;
import coppercore.parameter_tools.path_provider.EnvironmentHandler;
import edu.wpi.first.units.measure.Angle;
import edu.wpi.first.units.measure.Current;
import edu.wpi.first.units.measure.Distance;
import edu.wpi.first.units.measure.Time;
import edu.wpi.first.units.measure.Voltage;
import edu.wpi.first.wpilibj.Filesystem;

public class {{ name }}Constants {
  @JSONExclude
  public static final JSONSync<{{ name }}Constants> synced =
      new JSONSync<{{ name }}Constants>(
          new {{ name }}Constants(),
          "{{ name }}Constants.json",
          EnvironmentHandler.getEnvironmentHandler().getEnvironmentPathProvider(),
          new JSONSyncConfigBuilder().build());
  {%- if limit_sensing_method != "Current" %}

  public final Integer {{ limit_switch_name }}ID = {{ limit_switch_name|hash_can_id }};
  {%- endif%}

  {% for motor in motors %}
  public final Integer {{ motor }}Id = {{ motor|hash_can_id }}; // TODO: Replace placeholder CAN ID
  {%- endfor %}

  {%- for motor in motors%}
  {%- if motor != lead_motor%}
  public final Boolean invert{{ motor|upperfirst }}FollowerRequest = false;
  {%- endif %}
  {%- endfor %}

  public final InvertedValue kClawMotorInverted = InvertedValue.Clockwise_Positive;

  public final Current supplyCurrentLimit = Amps.of(40);
  public final Current statorCurrentLimit = Amps.of(40);

{% if limit_sensing_method == "CANrange" %}
  public final Distance proximityThreshold = Centimeters.of(8.0);
  public final Distance proximityHysteresis = Centimeters.of(0.5);
  public final Double minSignalStrengthForValidMeasurement = 2500.0;
{%- endif %}

  public final Voltage {{ game_piece|lowerfirst }}IntakeVoltage = Volts.of(3.0);
  public final Voltage {{ game_piece|lowerfirst }}Voltage = Volts.of(3.0);
{%- if limit_sensing_method == "Current" %}

  public final Current {{ game_piece|lowerfirst }}DetectionCurrent = Amps.of(10.0);

  public final Time {{ game_piece|lowerfirst }}CurrentDetectionTimeRising = Seconds.of(0.5);

  public final Time {{ game_piece|lowerfirst }}CurrentDetectionTimeFalling = Seconds.of(2.0);
{%- endif %}

  public static final class Sim {
    @JSONExclude
    public static final JSONSync<{{ name }}Constants.Sim> synced =
        new JSONSync<{{ name }}Constants.Sim>(
            new {{ name }}Constants.Sim(),
            Filesystem.getDeployDirectory()
                .toPath()
                .resolve("constants/ClawConstants.Sim.json")
                .toString(),
            new JSONSyncConfigBuilder().build());

    /** How long the motor must remain powered to intake or outtake a game piece */
    public final Double actionTimeSeconds = 1.0;

    /**
     * How many rotations per second the motor will spin per volt applied. This isn't a unit because
     * I couldn't fight the double-layered PerUnit mess to get it to do what I want.
     */
    public final double rotationsPerSecondPerVolt = 1.0;

    /** When piecePos > coralDetectionPoint, the simulated sensor can sense it */
    public final double coralDetectionPoint = 0.7;

    /** When piecePos < algaeDetectionPoint, the simulated sensor can sense it */
    public final Double algaeDetectionPoint = 0.7;
  }
}
